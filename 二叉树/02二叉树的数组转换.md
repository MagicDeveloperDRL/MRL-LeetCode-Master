# 【二叉树】数组转换

二叉搜索树是一种特殊的二叉树，它是一个**有序树**：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树。

上述特点决定了二叉树的中序遍历是有序递增的，会得到一个有序递增数组。

同时由于中序遍历的顺序特点，二叉搜索树在LeetCode中存在如下一类算法：

> 给定一个二叉搜索树和目标值，搜索和该目标值相关的值，我们将该类题目统称为**二叉搜索树的搜索算法**。

当然，和普通二叉树遍历完整个树来搜索某值，在部分搜索题目中确实可行，但是这就没有利用二叉搜索树的特性。

## 一、二叉搜索树的搜索算法

给定一个二叉搜索树和目标值，搜索和该目标值相等的节点。

### 1、递归法

```c++
	TreeNode* searchBST(TreeNode* root, int val) {
        //如果当前节点不存在，返回NULL
        if(root==NULL){
            return NULL;
        }
        //如果当前节点值与目标值相等，返回当前节点
        else if(root->val==val){
            return root;
        }
        //如果当前节点值大于目标值，搜索其左节点，返回其返回值
        else if(val<root->val){
            return searchBST(root->left,val);
        }
        //如果当前节点值小于目标值，搜索其右节点，返回其返回值
        else{
            return searchBST(root->right,val);
        }
    }
```

### 2、迭代法

```c++
	TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            //如果当前节点值与目标值相等，返回当前节点
            if(root->val==val){
                return root;
            }
            //如果当前节点值大于目标值，继续搜索其左节点
            else if(val<root->val){
                root=root->left;
            }
            //如果当前节点值小于目标值，继续搜索其右节点
            else{
                root=root->right;
            }
        }
        return NULL;
    }
```

二叉搜索树的搜索类算法都基于以上算法，请熟悉并勤加练习以上代码！

## 二、二叉搜索树的插入算法

二叉搜索树的插入算法有多种实现形式，最常见就是不改变二叉树结构的方式，如下图：

![image-20210730140030810](C:\Users\Lab\AppData\Roaming\Typora\typora-user-images\image-20210730140030810.png)

在该方式下，插入一个值本质上就是遍历二叉搜索树，找到合适的空节点，新建一个节点替换该空节点。

需要注意的是，**在链式结构中，想替换一个节点，不能直接给该节点赋值，而是要找到其父节点**。

### 1、递归法

```c++
TreeNode* insertIntoBST(TreeNode* root, int val) {
        //如果当前节点为空则返回要插入的节点
        if(root==NULL){
            TreeNode* newNode=new TreeNode(val);
            return newNode;
        }
        //向左子树插入
        if(val<root->val){
            root->left=insertIntoBST(root->left,val);
        }
        //向右子树插入
        else{
            root->right=insertIntoBST(root->right,val);
        }
        return root;
    }
```

观察上述递归算法，可以发现其基本就是二叉搜索树搜索算法的变体！

只不过搜索算法只需要找到节点返回即可，插入算法需要找到该节点，新建节点并赋值给父节点的指针。

### 2、迭代法

主要迭代法中要记录空节点的父节点，才能替换该空节点。

```c++
 TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* newNode=new TreeNode(val);
        //如果当前节点为空则返回要插入的节点
        if(root==NULL){
            return newNode;
        }
        //迭代寻找符合条件的空节点的父节点
        TreeNode* cur=root;
        TreeNode* parent=root;
        while(cur!=NULL){
            parent=cur;
            //向右子树插入
            if(cur->val<val){
                cur=cur->right;
            }
            //向左子树插入
            else if(cur->val>val){
                cur=cur->left;
            }
        }
        //给空节点的父节点重新赋值
        if(parent->val>val){
            parent->left=newNode;
        }
        else{
            parent->right=newNode;
        }
        return root;
    }
```

## 二、二叉搜索树的删除算法

二叉搜索树的删除算法和插入算法一样，但是删除算法可能改变二叉树结构，如下图：

