# 二叉搜索树

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树。

这就决定了二叉搜索树在LeetCode中会着重考察搜索型的算法。

> 给定一个二叉搜索树和目标值，搜索和该目标值相关的值，我们将该类题目统称为**二叉搜索树的搜索算法**。

当然，和普通二叉树遍历完整个树来搜索某值，在部分搜索题目中确实可行，但是这就没有利用二叉搜索树的特性。

## 一、二叉搜索树的搜索算法

给定一个二叉搜索树和目标值，搜索和该目标值相等的节点。

### 1、递归法

```c++
	TreeNode* searchBST(TreeNode* root, int val) {
        //如果当前节点不存在，返回NULL
        if(root==NULL){
            return NULL;
        }
        //如果当前节点值与目标值相等，返回当前节点
        else if(root->val==val){
            return root;
        }
        //如果当前节点值大于目标值，搜索其左节点，返回其返回值
        else if(val<root->val){
            return searchBST(root->left,val);
        }
        //如果当前节点值小于目标值，搜索其右节点，返回其返回值
        else{
            return searchBST(root->right,val);
        }
    }
```

### 2、迭代法

```c++
	TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            //如果当前节点值与目标值相等，返回当前节点
            if(root->val==val){
                return root;
            }
            //如果当前节点值大于目标值，继续搜索其左节点
            else if(val<root->val){
                root=root->left;
            }
            //如果当前节点值小于目标值，继续搜索其右节点
            else{
                root=root->right;
            }
        }
        return NULL;
    }
```

二叉搜索树的搜索类算法都基于以上算法，请熟悉并勤加练习以上代码！

## 二、二叉搜索树的插入算法

给定一个二叉搜索树和目标值，搜索和该目标值相等的节点。

因为二叉搜素树存储的是可以比较大小的数据，其遍历时

二叉搜索树不需要遍历整个搜索树。

不改变二叉树的结构在二叉搜索树中插入数据：

遍历二叉搜索树，遇到空节点插入节点即可。

需要遍历整个搜索树吗？不需要！搜索树是有方向的

思路：

1、如果当前节点为空则直接返回一个新节点

2、如果插入值小于当前节点值，插入左节点；否则插入右节点

```c++
TreeNode* insertIntoBST(TreeNode* root, int val) {
        //如果当前节点为空则返回要插入的节点
        if(root==NULL){
            TreeNode* newNode=new TreeNode(val);
            return newNode;
        }
        //向左子树插入
        if(val<root->val){
            root->left=insertIntoBST(root->left,val);
        }
        //向右子树插入
        else{
            root->right=insertIntoBST(root->right,val);
        }
        return root;
    }
```

