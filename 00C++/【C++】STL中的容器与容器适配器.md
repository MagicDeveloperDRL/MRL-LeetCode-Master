# 【C++】STL中的容器与容器适配器
 该文档记录作者刷LeetCode时经常用到的数据结构与相关API等。

[TOC]

C++ 中的STL（Standard Template Library，标准模板库）是每一位C++语言使用者必定涉及的工具库，我们有必要对其常用的数据结构和算法API进行梳理。

## 一、容器

用于存放数据的类模板在STL中被称为容器（container）。

### 1、容器的通用API

#### （1）容器大小

```C++
int size()：返回容器对象中元素的个数。
bool empty()：判断容器对象是否为空。
```

#### （2）插入移除操作

```c++
erase(...)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。
insert(...)：插入一个或多个元素。该函数参数较复杂，此处省略。
clear()：从容器中删除所有元素。
```

#### （3）迭代器操作

顺序容器和关联容器还有以下成员函数：

```c++
begin()：返回指向容器中第一个元素的迭代器。
end()：返回指向容器中最后一个元素后面的位置的迭代器。
rbegin()：返回指向容器中最后一个元素的反向迭代器。
rend()：返回指向容器中第一个元素前面的位置的反向迭代器。
```

如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。

#### （4）迭代器遍历

从前向后遍历：

```c++
//方式一：正向迭代器(从前向后遍历)
for (list<int>::iterator i = v.begin(); i != v.end(); i++) {  //用迭代器遍历容器
    cout << *i << " ";  //*i 就是迭代器i指向的元素
}
//方式二：正向迭代器(从前向后遍历)
for (auto i = v.begin(); i != v.end(); i++) {  //用迭代器遍历容器
    cout << *i << " ";  //*i 就是迭代器i指向的元素
}
```

从后向前遍历：

```c++
//方式一：反向迭代器(从后向前遍历)
for (list<int>::reverse_iterator i = v.rbegin(); i != v.rend(); i++) {  
    cout << *i << " ";  //*i 就是迭代器i指向的元素
}
//方式二：反向迭代器(从后向前遍历)
for (auto i = v.rbegin(); i != v.rend(); i++) {  //用迭代器遍历容器
    cout << *i << " ";  //*i 就是迭代器i指向的元素
}
```

### 2、容器的分类API

#### （1）顺序容器

顺序容器的特点是元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。

| 类模板 | 中文简称       | 使用场景                                                     | 相关链接                            |
| ------ | -------------- | ------------------------------------------------------------ | ----------------------------------- |
| vector | 可变长动态数组 | 容器的大小无法确定，需要高效的随机存取，而不在乎插入和删除的效率，通常在数组后添加元素，使用vector | [【C++】vector](./【C++】vector.md) |
| deque  | 双端队列       | 容器的大小无法确定，需要高效的随机存取，而不在乎插入和删除的效率，通常在数组前添加元素，使用deque | [【C++】deque](./【C++】deque.md)   |
| list   | 双向链表       | 容器的大小无法确定，需要大量的插入和删除，而不关心随即存取，则应使用list | [【C++】list](./【C++】list.md)     |

顺序容器都有以下常用成员函数：

```c++
front()：返回容器中第一个元素的引用。
back()：返回容器中最后一个元素的引用。
push_back()：在容器末尾增加新元素。
pop_back()：删除容器末尾的元素。
```

deque的API在vector基础上添加了头部元素的插入与删除：

```c++
void push_front (const T & val); //将 val 插入容器的头部
void pop_front(); //删除容器头部的元素
```

list的API在deque基础上添加了头部元素的插入与删除：

```c++
void remove (const T & val) //删除和 val 相等的元素/
```

#### （2）关联容器

关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。

默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用`<`运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。

使用关联容器的目的也就在于快速查找。在关联容器中查找元素和插入元素的时间复杂度都是 O(log(n))。从 begin() 到 end() 遍历整个关联容器，就是从小到大遍历整个容器。

在排好序的 vector 和 deque 上进行折半查找，时间复杂度也可以是 O(log(n))。但是，对于插入、删除和查询交替进行的情况，使用 vector 和 deque 的效率不高。因为它们上面的插入和删除操作会引起元素的移动，时间复杂度是 O(n)。

| 类模板        | 中文简称         | 使用场景                                                     | 底层实现              |
| ------------- | ---------------- | ------------------------------------------------------------ | --------------------- |
| set           | 排序不可重复集合 | 排好序的集合，不允许有相同元素；元素中的值不可修改，想修改需要先删除该元素再插入新元素 | 基于红黑树(RB-tree)； |
| multiset      | 排好可重复集合   | 排好序的集合，允许有相同元素；元素中的值不可修改，想修改需要先删除该元素再插入新元素 | 基于红黑树(RB-tree)； |
| unordered_set |                  |                                                              |                       |
| map           |                  | 每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的。不允许有多个元素的关键字相同。关键字不可修改，想修改需要先删除该关键字再插入新关键字； | 基于红黑树(RB-tree)； |
| multimap      |                  | 和 map 类似，差别在于元素的关键字可以相同；关键字不可修改，想修改需要先删除该关键字再插入新关键字； | 基于红黑树(RB-tree)； |
| unordered_map |                  |                                                              |                       |

除了所有容器共有的成员函数外，关联容器还具有以下成员函数：

- find：查找某个值。
- lower_bound：查找某个下界。
- upper_bound：查找某个上界。
- equal_range：同时查找上界和下界。
- count：计算等于某个值的元素个数。
- insert：插人一个元素或一个区间

## 二、容器适配器

除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器（adapters）：

| 类模板         | 中文简称   | 使用场景 | 底层实现    |
| -------------- | ---------- | -------- | ----------- |
| stack          | 栈         |          | 基于deque； |
| queue          | 队列       |          | 基于deque； |
| priority_queue | 优先级队列 |          | 基于heap；  |

容器适配器都有以下三个成员函数：

- push：添加一个元素。
- top：返回顶部（对 stack 而言）或队头（对 queue、priority_queue 而言）的元素的引用。
- pop：删除一个元素。

容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。
